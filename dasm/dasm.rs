#[path = "../misc/common/common.rs"]
mod common;
use common::{Instruction, Macro, Mnemonic, Token};

fn main() {
  let args: Vec<String> = std::env::args().collect();
  if args.len() != 3 {
    println!("Dasm: Usage: dasm <memory image file> <disassembly output file>");
    std::process::exit(1);
  }

  let memory_image_file: &String = &args[1];
  let disassembly_output_file: &String = &args[2];

  let memory_image: Vec<u8> = std::fs::read(memory_image_file).unwrap_or_else(|_| {
    println!("Dasm: Error: Unable to read file `{}`", memory_image_file);
    std::process::exit(1);
  });

  match memory_image.try_into() {
    Ok(slice) => {
      let disassembly_output = format!("# Generated by Dasm\n\n{}", disassemble(slice, "main"));
      std::fs::write(disassembly_output_file, disassembly_output).unwrap();
    }
    Err(_) => {
      println!(
        "Dasm: Error: Memory image `{}` has incorrect size",
        memory_image_file
      );
      std::process::exit(1);
    }
  };

  println!("Dasm: Done");
}

fn disassemble(memory_image: [u8; common::MEM_SIZE], entry_point: &str) -> String {
  let opcodes: Vec<u8> = Vec::from(memory_image);

  let instructions: Vec<Result<Instruction, u8>> = opcodes
    .into_iter()
    .map(common::opcode_to_instruction)
    .collect();

  let tokens: Vec<Token> = instructions
    .into_iter()
    .map(common::instruction_to_token)
    .collect();

  let mnemonics: Vec<Mnemonic> = tokens.into_iter().map(common::token_to_mnemonic).collect();

  let disassembly: String = format!(
    "{}\n{}",
    Token::MacroDef(Macro {
      identifier: entry_point.to_string(),
    }),
    mnemonics
      .into_iter()
      .enumerate()
      .zip(memory_image.into_iter())
      .map(|((index, mnemonic), opcode)| {
        format!(
          "  {} {} # {} {} {}",
          mnemonic,
          Token::AtDyn,
          Token::XXX(index as u8),
          Token::AtOrg,
          Token::AtDD(opcode)
        )
      })
      .collect::<Vec<String>>()
      .join("\n")
  );

  disassembly
}
