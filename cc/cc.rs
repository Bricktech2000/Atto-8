#[path = "../misc/common/common.rs"]
mod common;
use common::*;

mod codegen;
mod parse;

fn main() {
  let args: Vec<String> = std::env::args().collect();
  if args.len() != 3 {
    println!("CC: Usage: cc <C source file> <assembly output file>");
    std::process::exit(1);
  }

  let c_source_file = &args[1];
  let assembly_output_file = &args[2];

  let input = std::fs::read_to_string(c_source_file).unwrap_or_else(|_| {
    println!("CC: Error: Unable to read file `{}`", c_source_file);
    std::process::exit(1);
  });

  let translation_unit = parse::parse(input).unwrap_or_else(|e| {
    println!("CC: Error: {}", e);
    std::process::exit(1);
  });

  let tokens = codegen::codegen(translation_unit, "main").unwrap_or_else(|e| {
    println!("CC: Error: {}", e);
    std::process::exit(1);
  });

  let mnemonics: Vec<Mnemonic> = tokens.into_iter().map(common::token_to_mnemonic).collect();

  let assembly: String = mnemonics
    .into_iter()
    .map(|mnemonic| mnemonic.to_string())
    .collect::<Vec<String>>()
    .join(" ");

  // TODO import stdlib properly
  let assembly = format!(
    "@ lib/core.asm\nmul! @err div! @err mod! @err\n{}",
    assembly
  );

  let assembly = format!("# Generated by CC\n\n{}", assembly);

  std::fs::write(assembly_output_file, assembly).unwrap();

  println!("CC: Done");
}

#[derive(Debug)]
pub enum TranslationUnit {
  ExternalDeclarations(Vec<ExternalDeclaration>),
}

#[derive(Debug)]
pub enum ExternalDeclaration {
  FunctionDefinition(FunctionDefinition),
}

#[derive(Debug)]
pub enum FunctionDefinition {
  NameBody(String, CompoundStatement), // TODO does not obey grammar
}

#[derive(Debug)]
pub enum IntegerConstant {
  IntegerConstant(u8),
}

#[derive(Debug)]
pub enum CompoundStatement {
  MagicReturn(MagicReturn), // TODO does not obey grammar
}

#[derive(Debug)]
pub enum MagicReturn {
  AdditiveExpression(AdditiveExpression),
}

#[derive(Debug)]
pub enum AdditiveExpression {
  MultiplicativeExpression(MultiplicativeExpression),
  AdditiveExpressionAdditiveOperatorMultiplicativeExpression(
    Box<AdditiveExpression>,
    AdditiveOperator,
    MultiplicativeExpression,
  ),
}

#[derive(Debug)]
pub enum MultiplicativeExpression {
  CastExpression(CastExpression),
  MultiplicativeExpressionMultiplicativeOperatorCastExpression(
    Box<MultiplicativeExpression>,
    MultiplicativeOperator,
    CastExpression,
  ),
}

#[derive(Debug)]
pub enum CastExpression {
  UnaryExpression(UnaryExpression),
}

#[derive(Debug)]
pub enum UnaryExpression {
  UnaryOperatorCastExpression(UnaryOperator, Box<CastExpression>),
  ParenAdditiveExpressionParen(Box<AdditiveExpression>), // TODO does not obey grammar
  IntegerConstant(IntegerConstant),                      // TODO replaces PostfixExpression
}

#[derive(Debug)]
pub enum UnaryOperator {
  Negation,
  BitwiseComplement,
  LogicalNegation,
}

#[derive(Debug)]
pub enum AdditiveOperator {
  Addition,
  Subtraction,
}

#[derive(Debug)]
pub enum MultiplicativeOperator {
  Multiplication,
  Division,
  Modulo,
}
