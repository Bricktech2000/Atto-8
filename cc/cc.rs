#[path = "../misc/common/common.rs"]
mod common;
use common::{Error, Label, Macro, Mnemonic, Token};

use std::rc::Rc;

fn main() {
  let args: Vec<String> = std::env::args().collect();
  if args.len() != 3 {
    println!("CC: Usage: cc <C source file> <assembly output file>");
    std::process::exit(1);
  }

  let c_source_file = &args[1];
  let assembly_output_file = &args[2];

  let source = std::fs::read_to_string(c_source_file).unwrap_or_else(|_| {
    println!("CC: Error: Unable to read file `{}`", c_source_file);
    std::process::exit(1);
  });

  match translation_unit(source) {
    Ok((translation_unit, _)) => {
      let assembly = format!("# Generated by CC\n\n{}", codegen(translation_unit, "main"));
      std::fs::write(assembly_output_file, assembly).unwrap();
    }
    Err(e) => {
      println!("CC: Error: {}", e);
      std::process::exit(1);
    }
  }

  println!("CC: Done");
}

// elementary parsers

type ParseResult<T> = Result<(T, String), Error>;
type Parser<T> = Rc<dyn Fn(String) -> ParseResult<T>>;

fn any() -> Parser<char> {
  Rc::new(move |input: String| match &input[..] {
    "" => Err(Error(format!("Unexpected end of input"))),
    _ => Ok((input.chars().next().unwrap(), input[1..].to_string())),
  })
}

fn eof() -> Parser<()> {
  Rc::new(move |input: String| match &input[..] {
    "" => Ok(((), input)),
    _ => Err(Error(format!("Expected end of input, got `{}`", input))),
  })
}

// other parsers

fn satisfy(predicate: Rc<dyn Fn(char) -> bool>) -> Parser<char> {
  Rc::new(move |input: String| match any()(input) {
    Ok((char, input)) => match predicate(char) {
      true => Ok((char, input)),
      false => Err(Error(format!("Unexpected character `{}`", char))),
    },
    Err(e) => Err(e),
  })
}

fn char(c: char) -> Parser<()> {
  Rc::new(
    move |input: String| match satisfy(Rc::new(move |x| x == c))(input) {
      Ok((_, input)) => Ok(((), input)),
      Err(e) => Err(e),
    },
  )
}

fn whitespace() -> Parser<()> {
  Rc::new(move |input: String| {
    let ((), input) = choice(vec![char(' '), char('\n'), char('\t')])(input)?;
    Ok(((), input))
  })
}

fn whitespaces() -> Parser<()> {
  Rc::new(move |input: String| {
    let (_, input) = many(whitespace())(input)?;
    Ok(((), input))
  })
}

fn decimal_digit() -> Parser<char> {
  satisfy(Rc::new(move |x| x.is_digit(10)))
}

fn string(string: &'static str) -> Parser<()> {
  Rc::new(move |input: String| {
    string
      .chars()
      .map(char)
      .fold(Ok(((), input)), |acc, parser| {
        acc.and_then(|((), input)| parser(input))
      })
  })
}

// combinators

fn many<T: 'static>(parser: Parser<T>) -> Parser<Vec<T>> {
  Rc::new(move |input: String| {
    let mut result = vec![];
    let mut input = input;
    loop {
      match parser(input.clone()) {
        Ok((result_, input_)) => {
          result.push(result_);
          input = input_;
        }
        Err(_) => break,
      }
    }
    Ok((result, input))
  })
}

fn many1<T: 'static>(parser: Parser<T>) -> Parser<Vec<T>> {
  Rc::new(move |input: String| {
    let (first, input) = parser(input)?;
    let (rest, input) = many(parser.clone())(input)?;
    let mut result = vec![first];
    result.extend(rest);
    Ok((result, input))
  })
}

fn choice<T: 'static>(parser: Vec<Parser<T>>) -> Parser<T> {
  Rc::new(move |input: String| {
    for parser in parser.iter() {
      match parser(input.clone()) {
        Ok((result, input)) => return Ok((result, input)),
        Err(_) => continue,
      }
    }
    Err(Error(format!("No parser succeeded")))
  })
}

// C99 grammar

fn end_of_file(input: String) -> ParseResult<()> {
  let ((), input) = whitespaces()(input)?;
  let ((), input) = eof()(input)?;

  Ok(((), input))
}

#[derive(Debug)]
enum TranslationUnit {
  ExternalDeclarations(Vec<ExternalDeclaration>),
}

fn translation_unit(input: String) -> ParseResult<TranslationUnit> {
  // TODO should be `many` instead of `many1`
  let (external_declarations, input) = many1(Rc::new(external_declaration))(input)?;
  let ((), input) = end_of_file(input)?;

  Ok((
    TranslationUnit::ExternalDeclarations(external_declarations),
    input,
  ))
}

#[derive(Debug)]
enum ExternalDeclaration {
  FunctionDefinition(FunctionDefinition),
}

fn external_declaration(input: String) -> ParseResult<ExternalDeclaration> {
  let (function_definition, input) = function_definition(input)?;

  Ok((
    ExternalDeclaration::FunctionDefinition(function_definition),
    input,
  ))
}

#[derive(Debug)]
struct FunctionDefinition {
  name: String,
  body: CompoundStatement,
}

fn function_definition(input: String) -> ParseResult<FunctionDefinition> {
  let ((), input) = whitespaces()(input)?;
  let (_, input) = string("int")(input)?;
  let ((), input) = whitespaces()(input)?;
  let (_, input) = string("main")(input)?;
  let ((), input) = whitespaces()(input)?;
  let ((), input) = char('(')(input)?;
  let ((), input) = whitespaces()(input)?;
  let ((), input) = char(')')(input)?;
  let (compound_statement, input) = compound_statement(input)?;

  Ok((
    FunctionDefinition {
      name: "main".to_string(),
      body: compound_statement,
    },
    input,
  ))
}

#[derive(Debug)]
struct IntegerConstant {
  value: i32,
}

fn integer_constant(input: String) -> ParseResult<IntegerConstant> {
  let ((), input) = whitespaces()(input)?;
  let (digits, input) = many1(decimal_digit())(input)?;
  let value = String::from_iter(digits).parse::<i32>().unwrap();

  Ok((IntegerConstant { value }, input))
}

#[derive(Debug)]
enum CompoundStatement {
  MagicReturn(MagicReturn),
}

fn compound_statement(input: String) -> ParseResult<CompoundStatement> {
  let ((), input) = whitespaces()(input)?;
  let ((), input) = char('{')(input)?;
  let (magic_return, input) = magic_return(input)?;
  let ((), input) = whitespaces()(input)?;
  let ((), input) = char('}')(input)?;

  Ok((CompoundStatement::MagicReturn(magic_return), input))
}

#[derive(Debug)]
enum MagicReturn {
  ConstantExpression(ConstantExpression),
}

fn magic_return(input: String) -> ParseResult<MagicReturn> {
  let ((), input) = whitespaces()(input)?;
  let ((), input) = string("return")(input)?;
  let ((), input) = whitespaces()(input)?;
  let (constant_expression, input) = constant_expression(input)?;
  let ((), input) = whitespaces()(input)?;
  let ((), input) = char(';')(input)?;

  Ok((MagicReturn::ConstantExpression(constant_expression), input))
}

#[derive(Debug)]
enum ConstantExpression {
  IntegerConstant(IntegerConstant),
}

fn constant_expression(input: String) -> ParseResult<ConstantExpression> {
  let (integer_constant, input) = integer_constant(input)?;

  Ok((ConstantExpression::IntegerConstant(integer_constant), input))
}

// codegen

fn codegen(translation_unit: TranslationUnit, entry_point: &str) -> String {
  let jmp = Token::Sti;
  let here = Label {
    identifier: "here".to_string(),
    scope_uid: None,
  };
  let hlt = vec![
    Token::LabelDef(here.clone()),
    Token::LabelRef(here.clone()),
    jmp,
  ];
  let entry = vec![Token::MacroDef(Macro {
    identifier: entry_point.to_string(),
  })];

  let mut tokens: Vec<Token> = vec![];

  tokens.extend(entry);

  tokens.extend(match translation_unit {
    TranslationUnit::ExternalDeclarations(external_declarations) => {
      match &external_declarations[..] {
        [ExternalDeclaration::FunctionDefinition(function_definition)] => {
          match function_definition.name.as_str() {
            "main" => match &function_definition.body {
              CompoundStatement::MagicReturn(magic_return) => match magic_return {
                MagicReturn::ConstantExpression(constant_expression) => match constant_expression {
                  ConstantExpression::IntegerConstant(integer_constant) => {
                    vec![Token::XXX(integer_constant.value as u8)]
                  }
                },
              },
            },
            _ => todo!(),
          }
        }
        _ => todo!(),
      }
    }
  });

  tokens.extend(hlt);

  let mnemonics: Vec<Mnemonic> = tokens.into_iter().map(common::token_to_mnemonic).collect();

  let assembly: String = mnemonics
    .into_iter()
    .map(|mnemonic| mnemonic.to_string())
    .collect::<Vec<String>>()
    .join("\n");

  assembly
}
